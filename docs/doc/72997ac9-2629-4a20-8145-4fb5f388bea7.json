{
    "summary": "The code includes a \"draw_boxes\" function that imports libraries, takes input image and box coordinates, generates colors, creates an overlay with rectangles, optionally adds text, and saves the result as 'output.png'. It is used in conjunction with another function to overlay images with text by first identifying noun phrases from text and their bounding box positions, then creating a dictionary mapping them. The parse_response function resizes images while maintaining aspect ratio and converts extracted information into a format for drawing boxes on an image.",
    "details": [
        {
            "comment": "This code imports various libraries and defines a function called \"draw_boxes\" that takes an image, boxes coordinates, and text to draw on the image. It then generates colors for each box, creates an overlay with white background, draws rectangles around the boxes on the overlay, and optionally adds text inside the boxes if provided. The resulting image is saved as 'output.png'.",
            "location": "\"/media/root/Toshiba XG3/works/CogVLM/docs/src/utils/utils/grounding_parser.py\":0-26",
            "content": "import seaborn as sns\nfrom PIL import Image, ImageDraw, ImageFont\nimport matplotlib.font_manager\nimport spacy\nimport re\nnlp = spacy.load(\"en_core_web_sm\")\ndef draw_boxes(image, boxes, texts, output_fn='output.png'):\n    box_width = 5\n    color_palette = sns.color_palette(\"husl\", len(boxes))\n    colors = [(int(r*255), int(g*255), int(b*255)) for r, g, b in color_palette]\n    width, height = image.size\n    absolute_boxes = [[(int(box[0] * width), int(box[1] * height), int(box[2] * width), int(box[3] * height)) for box in b] for b in boxes]\n    overlay = Image.new('RGBA', image.size, (255, 255, 255, 0))\n    draw = ImageDraw.Draw(overlay)\n    font_path = sorted(matplotlib.font_manager.findSystemFonts(fontpaths=None, fontext='ttf'))[0]\n    font = ImageFont.truetype(font_path, size=26)\n    for box, text, color in zip(absolute_boxes, texts, colors):\n        for b in box:\n            draw.rectangle(b, outline=color, width=box_width)\n            if not text:\n                continue\n            splited_text = text.split('\\n')"
        },
        {
            "comment": "This code seems to be part of a larger function that takes an image, overlays it with text, and saves the result. It first defines functions `boxstr_to_boxes` and `text_to_dict`, which may be used elsewhere in the codebase. The main logic involves splitting the text into lines, calculating the position for each line of text based on the bounding box coordinates and font size, drawing a rectangle around each line of text, and then overlaying the image with text and saving the result.",
            "location": "\"/media/root/Toshiba XG3/works/CogVLM/docs/src/utils/utils/grounding_parser.py\":27-48",
            "content": "            num_lines = len(splited_text)\n            text_width, text_height = font.getbbox(splited_text[0])[-2:]\n            y_start = b[3] - text_height * num_lines - box_width\n            if b[2] - b[0] < 100 or b[3] - b[1] < 100:\n                y_start = b[3]\n            for i, line in enumerate(splited_text):\n                text_width, text_height = font.getbbox(line)[-2:]\n                x = b[0] + box_width\n                y = y_start + text_height * i\n                draw.rectangle([x, y, x+text_width, y+text_height], fill=(128, 128, 128, 160))\n                draw.text((x, y), line, font=font, fill=(255, 255, 255))\n    img_with_overlay = Image.alpha_composite(image.convert('RGBA'), overlay).convert('RGB')\n    img_with_overlay.save(output_fn)\ndef boxstr_to_boxes(box_str):\n    boxes = [[int(y)/1000 for y in x.split(',')] for x in box_str.split(';') if x.replace(',', '').isdigit()]\n    return boxes\ndef text_to_dict(text):\n    doc = nlp(text)\n    box_matches = list(re.finditer(r'\\[\\[([^\\]]+)\\]\\]', text))"
        },
        {
            "comment": "This code extracts noun phrases from text and their corresponding bounding box positions. It then creates a dictionary mapping each phrase to its associated box coordinates. The parse_response function resizes an image while maintaining aspect ratio.",
            "location": "\"/media/root/Toshiba XG3/works/CogVLM/docs/src/utils/utils/grounding_parser.py\":49-75",
            "content": "    box_positions = [match.start() for match in box_matches]\n    noun_phrases = []\n    boxes = []\n    for match, box_position in zip(box_matches, box_positions):\n        nearest_np_start = max([0] + [chunk.start_char for chunk in doc.noun_chunks if chunk.end_char <= box_position])\n        noun_phrase = text[nearest_np_start:box_position].strip()\n        if noun_phrase and noun_phrase[-1] == '?':\n            noun_phrase = text[:box_position].strip()\n        box_string = match.group(1)\n        noun_phrases.append(noun_phrase)\n        boxes.append(boxstr_to_boxes(box_string))\n    pairs = []\n    for noun_phrase, box_string in zip(noun_phrases, boxes):\n        pairs.append((noun_phrase.lower(), box_string))\n    return dict(pairs)\ndef parse_response(img, response, output_fn='output.png'):\n    img = img.convert('RGB')\n    width, height = img.size\n    ratio = min(1920 / width, 1080 / height)\n    new_width = int(width * ratio)\n    new_height = int(height * ratio)\n    new_img = img.resize((new_width, new_height), Image.LANCZOS)"
        },
        {
            "comment": "Extracts box positions and corresponding texts from the response, converts them into a format for drawing boxes on an image.",
            "location": "\"/media/root/Toshiba XG3/works/CogVLM/docs/src/utils/utils/grounding_parser.py\":76-85",
            "content": "    pattern = r\"\\[\\[(.*?)\\]\\]\"\n    positions = re.findall(pattern, response)\n    boxes = [[[int(y) for y in x.split(',')] for x in pos.split(';') if x.replace(',', '').isdigit()] for pos in positions]\n    dic = text_to_dict(response)\n    if not dic:\n        texts = []\n        boxes = []\n    else:\n        texts, boxes = zip(*dic.items())\n    draw_boxes(new_img, boxes, texts, output_fn=output_fn)"
        }
    ]
}